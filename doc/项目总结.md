# Cloudeye，云端天眼
[toc]
## 项目概述
- 以人脸识别为基础，结合视频人流检测和LBS定位技术，进行大规模图片检索的失踪儿童预警跟踪公益平台。
- 项目包括：server服务器[也就是本项目]，PC摄像头检测系统，android客户端demo，web警察局监控系统demo

## 功能特性
> 详见: ./doc/Cloudeye需求文档

### 失踪儿童检测功能
> 在机场,火车站,汽车站等各式各样的安检出入口的摄像头可以接入系统的检测系统,用于实时的人流检测，当检测系统成功从视频中获取、处理完成图片信息完成之后，云端收到待搜索图片之后,进行人脸搜索

1. 人流信息检测:利用监控摄像头检测人流
2. 上传图片和地理位置信息:检测系统上传图片信息
3. 超分辨率图片还原：使用神经网络提高摄像头的图片质量
3. 人脸搜索:云端实时搜索数据库中的人脸,判断是否配对
4. 消息推送:若发现相似人脸,启动信息预警信息推送

### 用户联动协助
> 在用户在线的状态的情况下,在以下条件发生的时候,用户会收到消息:
1. 周围的检测系统检测到的疑似被拐儿童的信息;
2. 周围的用户拍摄到高匹配率的被拐儿童图片之后;
3. 一位周围的求助者发送了实时求助消息之后

> 用户收到消息后,如果发现疑似被拐儿童,可以选择拍照上传识别,用户若上传的照片被云端计算判定为同一张人脸,则进行联动扩散消息

1. 基于 LBS 的消息推送:推送求助消息给周围的用户
2. 拍照和人脸相似度比较:用户通过拍照来进行联动协助
3. 基于地理位置联动扩散消息:云端若发现用户上传了高匹配度的消息,则进一步基于拍摄者周围扩散求助消息
4. 获得走失小孩详细信息

### 实时求助功能
> 用户(必须提前进行实名认证)发现自己的小孩走丢了,可以通过上传照片和填写个人信息发布求助信息,求助信息会被立即推送给周围的用户。当自己的发布的被拐小孩有了新的进展之后,用户可以收到进展消息。当找到小孩之后,用户需要进行结案，停止求助联动扩散

1. 发布求助:用户可以发布自己失踪的小孩的详细信息
2. 接受最新进展:(如果有的话),用户会收到小孩的最新跟踪进展
3. 结案:当找到小孩之后,用户需要手动停止求助联动扩散

### 用户主动识别失踪儿童
> 用户如果发现某个孩子疑似被拐儿童(行为可疑),可以主动进行拍照识别,上传到云端。云端收到待搜索图片之后,进行人脸搜索。当识别出高匹配度的人脸之后,需要把这个消息推送出去

1. 上传图片和地理位置信息:用户上传拍摄小孩的图片和当前地理位置信息
2. 人脸搜索:云端实时搜索数据库中的人脸,判断是否配对
3. 消息推送:若发现相似人脸,启动信息预警信息推送

### 警察局局部消息监控
> 每个警察局能够设定自己的监控区域范围的最新发生的所有跟拍和求助消息。警察局点击其中的一个小孩之后，可以查看小孩的档案详情；
> 我们可以对所有的跟踪数据进行数据挖掘和分析，比如，了解失踪儿童的集群行为。分析各个地点的轨迹跟踪记录，进行小孩的未来走势预测。形成可视化的热力图等等。

1. 警察局监控局部地域内的所有推送的消息
2. 查看某个失踪小孩的详细信息和轨迹
3. 对失踪儿童记录进行数据挖掘和分析

### 警察局对小孩档案管理
> 警察局可以查看数据库中的所有小孩的档案详情记录，并且方便的按照条件进行搜索和筛选。

1. 按照最后发现时间排序,显示未立案/已立案的失踪小孩的列表
2. 按照时间段,小孩名称,走失地点筛选失踪小孩

## 技术路线
1. 服务器：Python2.7，Tornado
2. 数据库：MongoDB，MySQL
3. 负载均衡：Nginx
4. 人脸识别搜索：face++云服务
5. 超分辨率图片还原：深度递归卷积神经网络
6. 图片存储：阿里云OSS对象存储服务器

## 项目架构
> 详见：./doc/Cloudeye概要设计文档.doc
> 软件使用 MVC 实现 SOA 架构,并在数据存储访问使用 ORM 技术,具体而言,系统分为应用层,控制层,基础服务层,数据模型层,数据存储层和第三方云服务

### 应用层
直接面向用户,调用接口层提供的 api,完成数据的获取,并在应用层显示给用户,包括:
- **Android 客户端**:提供给用户使用的终端
- **Web 端**:提供给警察局使用的监控系统
- **摄像头**:完成和云端交互的检测系统

### 接口层
调用服务层提供的服务组合,实现该接口所需的全部功能,接口层的各个模块相互解耦,不可以相互调用:
- **寻找小孩模块**:实现寻找小孩相关的操作,搜索失踪小孩,发布事实求助,疑似小孩跟踪等;
- **失踪小孩模块**:用于实现失踪小孩信息的获取的相关操作,包括获取失踪小孩详情,按照地域,时间等条件筛选小孩档案等接口
- **账户操作模块**:实现账户相关操作,包括登陆,注册,注销,忘记密码,获取我提交的报案的最新进展,
获取我收到的小孩求助

### 基础服务层
以面向服务为单位,按照模块划分出完成接口层所需要的最基础的服务单元,基础服务层调用数据模型层提供的接口实现相关操作,其中,各个服务模块的接口相互解耦,不可相互调用,包括:
- **人脸引擎服务**:完成和人脸识别相关的服务,包括人脸的检测,搜索,比对,计算置信度等的服务
- **消息服务**:完成和消息推送相关的服务,包括不同类型的消息推送,消息的清空和按照区域获取消息
- **失踪小孩服务**:完成和失踪小孩相关的服务,包括新的小孩的上传,小孩状态的更新,小孩的信息获取
- **用户信息服务**:完成用户和用户账号相关的服务,包括新增,登陆,清除,更新状态,获取用户信息,
获得推送,清空推送等服务
- **图片服务**:完成和图片相关的服务,包括预处理,上传,删除,获取访问权限版

### 数据模型层
面向数据库和第三方云服务,为基础服务建立对应的数据模型,为基础服务提供接口,各个数据模型相互解耦,不可相互调用,具体包括:
- **人脸数据模型**:直接连接 face++服务器,调用人脸的查找(识别,搜索,对比,获取详情),进行人脸的增加,删除
- **地理位置模型**:维护在线用户和地理位置的映射关系,提供在线用户的地理位置设置,更新,清空,按照地理位置进行用户筛选等功能
- **消息模型**:维护推送消息相关的数据模型,包括按照时间,区域进行消息筛选,消息的更新,新增,删
除,获取等功能
- **静态资源模型**:直接连接 OSS 对象存储服务器,进行资源上传,下载,授权,删除等操作
- **失踪小孩模型**:维护失踪小孩的模型,进行小孩的数据上传,数据更新,条件查找,获取详情信息,获
取跟踪轨迹,更新跟踪轨迹,删除跟踪轨迹等功能
- **用户信息模型**:与用户相关的模型,进行用户的增删改查,并维护用户的失踪人员列表等
##存在的问题和解决方案

1. 系统架构
3. 把所有的第三方服务在数据模型层阶段封装，在上层屏蔽，方便之后替换第三方业务的时候比较方便
5. 以search为例，介绍我的系统架构的好处
6. 而是在没有听说过SOA架构之前，自己根据自己的需求情况设计了一套系统架构，后来在某天巧合发现，我的系统架构竟然是SOA架构？？
7. 使用redis实现了一个用户接受消息的队列：Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。
8. 
---------

3. 自动化生成数据脚本
7. 我在设计api的时候，不是很规范，系统完成之后才知道restful api 是有他比较规范的设计方法的
8. 异常处理，
	- 以前返回给客户端的时候都是 500 error，所有的状态码都是 在返回提中。这次我重写了所有http返回类，用不同的状态码来告诉客户端目前出现的具体错误，加快了调试速度。
	- 数据库的一致性，mongodb，mysql，face++，oss，数据库分布在很多个地方，同一个id会被用很多次，所以在调试过程中存在的问题就是如果中间某个步骤一旦出错，这里的数据库就会出现不一致，这会造成之后很多数据获取时的错误；
	- 对所有的错误操作都做了回滚处理，保证了数据的一致性

9. 一个方法的灵活性和封装性是可能存在冲突的，如何解决这个冲突？
eg. def find_user_in_range(self, coordinate, distance),这个接口，用来获取一定经纬度范围的用户，
我这里使用了distance的参数，让用户自己标定查找范围，这样就可以适应不同distance的查找需求，
- 方案一，使用distance参数，封装性下降，灵活性上升：
比如我修改了find_user_in_range的实现机制，我发现需要使用类似椭圆的形式进行查找，那么这个函数的输入参数就需要修改，由原本的distance变成长轴和短轴两个参数，所有用到这个方法的地方都要进行修改
- 方案二，不使用distance参数，封装性上升，灵活性下降：
如果我之前设计的时候假设distance使用固定的距离，那么这个时候他的封装性就提升了，当我需要修改其实现机制，变成椭圆的时候，此时我不需要修改所有用到这个方法的地方，只需要修改这个方法的内部实现就行。
- 解决方案：
在我的应用中，find_user_in_range()这个方法涉及到的distance是需要被提出来的，因为不同的用户组，使用的range是不一样的(警察和普通用户)，方法改成find_user_in_range(self, coordinate, length,width)
- 结论：
不要盲目的增加一个方法的灵活性，因为这样的代价就是损失他的封装性，逻辑设计的变动可能导致一系列的改动，也就是耦合性也会提高；但是适当的考虑方法的通用性是必要的，它能够提高代码重用率。我的方法论是，考虑一个方法所可能的灵活程度是怎么样的，在满足灵活度需求的基础上最大限度提高其封装性

4. 没有提前规定好词汇表，导致最后在编码的时候有些相同意义的字段用了不同的名字，处理的时候出现了一点不方便的事情
5. 搜索功能的性能很糟糕，正在做优化


最近一直在研究Tornado异步操作，然而一番研究后发现要使一个函数异步化的最好方法就是采用相关异步库，但目前很多功能强大的库都不在此列。经过一番查找文档和搜索示范，终于发现了ThreadPoolExecutor模块和run_on_executor装饰器。用法就是建立线程池，用run_on_executor装饰的函数即运行在其中线程中，从而从主线程中分离出来，达到异步的目的。
另外，Tornado的IOLoop实例还有IOLoop.add_callback(callback, *args, **kwargs)方法，文档中的描述如下：